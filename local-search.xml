<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>microprocessor</title>
    <link href="/2023/11/14/microprocessor/"/>
    <url>/2023/11/14/microprocessor/</url>
    
    <content type="html"><![CDATA[<h1 id="microprocessor">Microprocessor</h1><p>This class is an elective course in NTHU's electrical engineeringprogram. I'm documenting the lab content as notes with the hope that itcan assist others who are taking similar courses.</p><p>This course uses 8051, a Microprocessor developed by Microsoft backin 1980s. The following content is some introduction to 8051.</p><h2 id="characteristics-and-features-of-8051">Characteristics andFeatures of 8051</h2><ol type="1"><li>Architecture: The 8051 microcontroller uses a Harvard architecture,which means it has separate buses for program memory (ROM/Flash) anddata memory (RAM). It is an 8-bit microcontroller, meaning it processesdata in 8-bit chunks.</li><li>Memory: The 8051 typically includes 4 KB of on-chip ROM (programmemory) and 128 bytes of on-chip RAM (data memory). Some variants mayhave more memory or additional features.</li><li>CPU: It has a single 8-bit CPU core with a wide range of addressingmodes, making it suitable for a variety of tasks. It can execute mostinstructions in one to two machine cycles.</li><li>Peripherals: The 8051 microcontroller features a variety of on-chipperipherals, including timers/counters, serial communication ports(UART), I/O ports, and interrupt control. These peripherals can be usedfor tasks such as timing, communication, and general-purpose input andoutput.</li><li>Clock Speed: The 8051 typically operates at a clock speed of 12 MHzor less, although some variants can run at higher speeds.</li><li>Instruction Set: The 8051 instruction set is known for itssimplicity and ease of use. It includes a wide range of instructions fordata manipulation, logical operations, branching, and more.</li><li>Interrupt System: The 8051 features a flexible interrupt system,allowing it to respond to external events and prioritize interrupts asneeded.</li><li>I/O Ports: It has four 8-bit I/O ports (P0, P1, P2, and P3), whichcan be configured as inputs or outputs. These ports are often used forinterfacing with external devices.</li><li>Low Power Modes: Many 8051 microcontroller variants support lowpower modes to conserve energy when the device is idle.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>NTHU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reverse_Assembly</title>
    <link href="/2023/09/24/Reverse-Assembly/"/>
    <url>/2023/09/24/Reverse-Assembly/</url>
    
    <content type="html"><![CDATA[<h1 id="reverse">Reverse</h1><p>This article is mostly about the basic knowledge ofassembly.Including some basic instruction, calling convention and a lotmore. There might have dozens of grammar mistake. Please tell me if youfind any.註:大部分筆記都是在我用虛擬機的時候打的，因為在虛擬機不想要一直切換輸入法，所以虛擬機中只有英文，請多多見諒。</p><h2 id="register">Register</h2><p>Most register don't have specific function. While <code>ESP</code>and <code>EBP</code> have specific function.</p><ul><li><strong>ESP</strong>: stack pointer.</li><li><strong>EBP</strong>: base pointer.</li><li><strong>rip</strong>: the instruction pointer, point to the nextintruction.</li><li><strong>rsp</strong>: the stack pointer, point to the top of thestack. <code>EAX(32bits)</code> can be viewed as two<code>AX(16bits)</code> combine together. and the higher part of<code>AX</code> is <code>AH(bits)</code>, while the lower part of<code>AX</code> is <code>AL(bits)</code>.</li></ul><h1 id="assembly">Assembly</h1><h3 id="declaration-of-static-data">Declaration of static data</h3><p>use <code>data</code> to start declaration data. <code>.byte</code>,<code>short</code>, <code>long</code>, are instruction of declaration,which decide how many memory will this variable take. <code>byte</code>:one byte. <code>short</code>: two byte. <code>long</code>: four byte.<code>zero</code>: to setup series of zero. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">.data<br>    barr:<br>           .zero <span class="hljs-number">10</span>; <span class="hljs-comment">// declaring ten bytes of zero right afer the position of the label.</span><br>    var :<br>           .byte <span class="hljs-number">64</span> ;declare var, and the data is <span class="hljs-number">64</span><br>           .byte <span class="hljs-number">10</span> ;declare a nother data <span class="hljs-number">10</span>, this data have no so-called label, the address is var+<span class="hljs-number">1.</span><br>       <br></code></pre></td></tr></table></figure> ##commands</p><h3 id="the-operating-suffix">the operating suffix:</h3><p>a given memory address of the data types from referenced Assemblyinstructions inferred. However, in some cases, we use the memory in the“ pit “ of the size is not clear. Say this Directive mov<code>$2,(%ebx)</code>. This Directive whether it should be “ 2 “ forthis value to move to EBX in value represents the address of the “ pit “of a single byte ? Perhaps it is represented by a 32-bit integerrepresentation of 2 is moved to the From address EBX beginning of the 4bytes. Since these two explanations are plausible, but computerassembler must be clear which explanation is correct, the computer isvery simple, either is wrong or right. Prefix <code>b</code>,<code>w</code>, and <code>l</code> is to solve this problem, which aredenoted 1, 2 and 4 bytes in size. ## Data Movement Instruction</p><h3 id="move">move:</h3><p>this command basically copy the data of the first parameter, andcover the data of the second parameter. <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">mov (<span class="hljs-variable">%ebx</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span><span class="hljs-comment">; move the data inside ebx into eax. (%eax) means the data stored inside eax</span><br>mov (<span class="hljs-variable">%ebx</span>)<span class="hljs-punctuation">,</span> var<span class="hljs-comment">; move four bytes of data inside ebx into var. </span><br>mov (<span class="hljs-variable">%esi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%ebx</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-punctuation">,</span> ESI<span class="hljs-comment">; To move the four bytes of data, which starts from ESI+4*EBX, into EDX; </span><br></code></pre></td></tr></table></figure> :warning: Notedthat if you write to a 32-bit partial(e.g. eax), the CPU will zero outthe rest of the register.</p><h3 id="push">push:</h3><p>move the parameter into the top of the stack. First of all, thenumber of <code>ESP-4</code>, and the <code>ESP</code> will point to thenext bytes. &gt; the stack memory is from high to low. <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">push</span> %eax; <span class="hljs-built_in">push</span> eax into stach <br><span class="hljs-built_in">push</span> <span class="hljs-keyword">var</span>; <span class="hljs-built_in">push</span> <span class="hljs-keyword">var</span> into stack (<span class="hljs-number">4</span> bytes)<br></code></pre></td></tr></table></figure></p><h3 id="pop">pop:</h3><p>remove 4 bytes of data from stack, and put into a specific parameter.and let <code>ESP+4</code> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">pop %edi; remove <span class="hljs-keyword">the</span> data <span class="hljs-built_in">from</span> stack, <span class="hljs-keyword">and</span> <span class="hljs-built_in">put</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">into</span> edi.<br>pop (%ebx); remove <span class="hljs-keyword">the</span> data <span class="hljs-built_in">from</span> stack, <span class="hljs-keyword">and</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">put</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">four</span> <span class="hljs-keyword">bytes</span> starting <span class="hljs-built_in">from</span> edx.<br></code></pre></td></tr></table></figure> &gt; stack is thedata-structure that is first in last out, last in first out.</p><h3 id="lea">lea:</h3><ul><li>Load effective address.</li><li>lea Instruct to the first parameter specifies the memory unit intothe second parameter of the specified register. Note that this commanddoes not load the memory unit of the content, just calculate theeffective address and put it into the register. This is for obtaining apointer to a memory area of a pointer or to perform simple arithmeticoperations is very useful.</li><li>Noted that lea is one of the few function that can directly accessthe rip register. <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">lea (<span class="hljs-variable">%ebx</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%esi</span><span class="hljs-punctuation">,</span><span class="hljs-number">8</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%edi</span> <span class="hljs-comment">;the value of EBX+8*ESI is moved to EDI</span><br>lea val(<span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span> <span class="hljs-comment">;the value of val is moved to EAX</span><br>lea eax<span class="hljs-punctuation">,</span> [rip] # <span class="hljs-keyword">load</span> the next instruction into rax.<br></code></pre></td></tr></table></figure></li></ul><h2 id="logical-operation-instruction">Logical OperationInstruction</h2><h3 id="add">add:</h3><p><code>add</code> Instruction will sum up the two parameter, and theresulted will be stored in second parameter. <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">add</span> $<span class="hljs-number">10</span>, %eax ;EAX 中的值被设置为了 EAX+<span class="hljs-number">10</span>.<br><span class="hljs-attribute">addb</span> $<span class="hljs-number">10</span>, (%eax) ;往 EAX 中的值 所代表的内存单元地址 加上 <span class="hljs-number">1</span> 个字节的数字 <span class="hljs-number">10</span>.<br></code></pre></td></tr></table></figure> ### sub:subInstruction will be the second parameter value of the firstsubtraction, is behind the minus in front of that, then the result isstored to the second parameter. And addAs, both parameters can be aregister, but the two parameters can have at most one memory unit.<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> %<span class="hljs-title">ah</span>, %<span class="hljs-title">al</span> </span>;AL 被设置成 AL-AH<br><span class="hljs-function"><span class="hljs-keyword">sub</span> $216, %<span class="hljs-title">eax</span> </span>;将 EAX 中的值减去 <span class="hljs-number">216</span><br></code></pre></td></tr></table></figure></p><h3 id="inc-dec">inc, dec:</h3><p><code>inc</code> make the parameter plus 1, and <code>dec</code> makethe parameter minus 1.</p><h3 id="imul">imul:</h3><ul><li>integer multiplication</li><li>There are two form: 2 parameter, 3parameter.</li></ul><ol type="1"><li>two parameter:the first two parameters are multiplied, then theresult is stored to the second parameter. Result of the operation ( i.e.the second parameter ) must be a register.</li><li>three parameter: the first is it will be the 1st parameter and thefirst 2 parameters are multiplied, then the result is stored to thefirst 3 parameters, and of course, the 3rd parameter must be a register.In addition, the 1 argument must be a constant. <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">imul (<span class="hljs-variable">%ebx</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span> <span class="hljs-comment">;将 EAX 中的 32 位整数, 与 EBX 中的内容所指的内存单元, 相乘, 然后把结果存到 EAX 中.</span><br>imul $<span class="hljs-number">25</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%edi</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%esi</span> <span class="hljs-comment">;ESI 被设置为 EDI * 25.</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="idiv">idiv:</h3><ul><li>integer divider</li><li>此操作數為除數，而被除數則為EDX : EAX 中的內容（一個64位的整數），除法結果( 商) 存在EAX 中, 而所得的餘數存在EDX 中. <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">idiv <span class="hljs-variable">%ebx</span> <span class="hljs-comment">;用 EDX : EAX 的值除以 EBX 的值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br>idivw (<span class="hljs-variable">%ebx</span>) <span class="hljs-comment">;将 EDX : EAX 的值除以存储在 EBX 所对应内存单元的 32 位值. 商存放在 EAX 中, 余数存放在 EDX 中.</span><br></code></pre></td></tr></table></figure> ### and, or , xor: These instructions are for their parameters to theappropriate logic operation, the operation result is stored to the<strong>first </strong>parameter. ### shr, shl: bitwise shift, move thedigit by the second parameter of the decision, to move after the vacancyto get 0 up.</li></ul><h2 id="flow-control-instruction">Flow Control Instruction</h2><p>x86 處理器有一個指令指針寄存器( EIP ), 該寄存器為32 位寄存器,它用來在內存中指示我們輸入彙編指令的位置.就是說這個寄存器指向哪個內存單元,那個單元存儲的機器碼就是程序執行的指令.通常它是指向我們程序要執行的下一條指令. 但是你不能直接操作EIP 寄存器,你需要流程控制指令來隱式地給它賦值.</p><h3 id="jmp">jmp:</h3><p>jump to the assigned address. And execute the code at the address.&gt; jmp ususally jump to label. <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">    mov <span class="hljs-number">8</span>(<span class="hljs-variable">%ebp</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%esi</span><br><span class="hljs-symbol">begin:</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-variable">%ecx</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%ecx</span><br>    mov (<span class="hljs-variable">%esi</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span><br> ...................<br> jmp <span class="hljs-keyword">begin</span> <span class="hljs-comment">; jump to the begin label </span><br>          <br></code></pre></td></tr></table></figure></p><h3 id="cmp">cmp:</h3><p>compare the value of two number. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">cmpb $<span class="hljs-number">10</span>, (%ebx)<br>jeq loop; <span class="hljs-comment">// if the number in ebx is equal to 10, then jump into the &quot;loop&quot; label.</span><br></code></pre></td></tr></table></figure></p><h3 id="jcondition">jcondition:</h3><p>這些指令是條件跳轉指令, 它們基於一組條件代碼的狀態,這些條件代碼的狀態存放在稱為機器狀態字( machine status word )的特殊寄存器中. 機器狀態字的內容包括關於最後執行的算術運算的信息. 例如,這個字的一個位表示最後的結果是否為0. 另一個位表示最後結果是否為負數.基於這些條件代碼, 可以執行許多條件跳轉. 例如,如果最後一次算術運算結果為0, 則 jz 指令就是跳轉到指定參數標籤. 否則,程序就按照流程進入下一條指令.</p><p>許多條件分支的名稱都是很直觀的, 這些指令的運行,都和一個特殊的比較指令有關, cmp( 見下文). 例如, 像 jle 和 jne 這種指令,它們首先對參數進行 cmp 操作. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">je &lt;label; <span class="hljs-comment">//jump when equal; </span><br>jne &lt;label; <span class="hljs-comment">//jump when not equal;</span><br>jz &lt;label; <span class="hljs-comment">//jump when the result is 0;</span><br>jg &lt;label; <span class="hljs-comment">//jump when greater;</span><br>jge &lt;label;<span class="hljs-comment">//jump when greater or equal;</span><br>jl &lt;label; <span class="hljs-comment">//jump when less;</span><br>jle &lt;label; <span class="hljs-comment">//jump when less or equal;</span><br></code></pre></td></tr></table></figure></p><h4 id="example">example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cmp %ebx, %eax<br>jle done<br>;<span class="hljs-keyword">if</span> the value in ebx is smaller than eax, then jump to <span class="hljs-string">&quot; done &quot;</span> label, or execute the following instruction.<br></code></pre></td></tr></table></figure><h3 id="call-ret">call, ret:</h3><p>while calling a function, the computer record the current addressinto the stack. when the process is over, return will bring the EIP tothe previous address. <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">call &lt;label;<br>ret ;<br></code></pre></td></tr></table></figure></p><h2 id="calling-convention">Calling Convention:</h2><p>為了方便不同的程序員去分享代碼和運行庫, 並簡化一般子程序的使用,程序員們通常會遵守一定的約定( Calling Convention ).調用約定是關於如何從例程調用和返回的協議.例如，給定一組調用約定規則，程序員不需要檢查子例程的定義來確定如何將參數傳遞給該子例程.此外，給定一組調用約定規則，可以使高級語言編譯器遵循規則，從而允許手動編碼的彙編語言例程和高級語言例程相互調用</p><h3 id="caller-rules">Caller Rules:</h3><ol type="1"><li>In the subroutine call, should save some of the contents of theregister. Caller saved register are EAX, ECX, EDX. Because theseregister may be used when the subroutine is running, so the value ofregister should be push into stack.</li><li>If we want to pass some parameter to the subroutine, we should pushthe parameter into stack before calling function. The last parametershould be put into the stack first.</li><li>To call a subroutine, use <code>call</code> instruction.</li></ol><blockquote><p>After return, the return value should be inside EAX. To return tomachine state, we should 1.remove parameter from stack. 2.put the EAX,ECX, EDX previous value, which is put into stack previously, back intoEAX, ECX, EDX.</p></blockquote><h3 id="example-1">Example:</h3><p>下面的代碼就是個活生生的例子, 它展示了遵循約定的函數調用.調用者正在調用一個帶有3 個整數參數的函數myFunc. 第一個參數是EAX,第二個參數是常數216; 第三個參數位於EBX 的值所代表的內存地址.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">push (%ebx) <span class="hljs-comment">//put the third parameter into stack.</span><br>push $<span class="hljs-number">216</span> ;<span class="hljs-comment">//put the second parameter into stack.</span><br>push %eax ; <span class="hljs-comment">//put the first parameter into stack.</span><br>call myFunc ;<span class="hljs-comment">//calling this function </span><br>add $<span class="hljs-number">12</span>, %esp <span class="hljs-comment">// to move the pointer of the stack, to where there are no parameter.</span><br></code></pre></td></tr></table></figure> &gt; Stack is viewed as a temperary data saver.</p><h3 id="callee-rules">Callee Rules:</h3><p>subroutine should follow the some rule at the beginning ofsubroutine. 1. Push the value of EBP into stack, and copy the data ofESP into EBP. 2. Create space inside stack. Recall that stack growthdownward, therefore, we should minus the pointer to stack to create morespace. <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sub $<span class="hljs-number">12</span>, %esp; <span class="hljs-built_in">create</span> <span class="hljs-number">12</span>bits <span class="hljs-keyword">of</span> <span class="hljs-literal">space</span> <span class="hljs-built_in">to</span> stack, which is <span class="hljs-keyword">the</span> <span class="hljs-literal">space</span> <span class="hljs-keyword">of</span> <span class="hljs-literal">three</span> <span class="hljs-keyword">words</span>.<br></code></pre></td></tr></table></figure> 3. Callee-saved register EBX,EDI,ESI will beretained by calling convention.</p><h3 id="return">return:</h3><ol type="1"><li>save the return value inside EAX.</li><li>Restore any modified register value.calleed saved old value.</li><li>release some variable, done this by adding corresponding value.</li><li>After returning, pop EBP in stack to restore caller's base pointvalue. Recall that we push the EBP when we were calling asubroutine.</li><li>Through the implementation of <code>ret</code> Instruction toreturn.</li></ol><h3 id="example-2">Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">.text;<span class="hljs-comment">//将 myFunc 定义为全局 ( 导出 ) 函数</span><br>    .globl myFunc<br>    .type myFunc, @function<br>    myFunc :<br>    ;prologue<br>    push %ebp ;<span class="hljs-comment">//saved the caller&#x27;s base pointer</span><br>    mov %esp, %ebp ;<span class="hljs-comment">//set new base pointer.</span><br>    sub $<span class="hljs-number">4</span>, %esp ; <span class="hljs-comment">//create 4 bytes space. </span><br>    push %edi; <br>    push %esi ;this function will modify EDI and ESI, so push them into <span class="hljs-built_in">stack</span>.<br>    ;<span class="hljs-comment">//there is no need to save EBX, EBP and ESP</span><br>    ;<span class="hljs-comment">//main part of the subroutine</span><br>    mov <span class="hljs-number">8</span>(%ebp), %eax ;<span class="hljs-comment">//move parameter 1 into EAX. [ebp+8] -&gt; eax</span><br>    mov <span class="hljs-number">12</span>(%ebp), %esi ;<span class="hljs-comment">//move second parameter into ESI. [ebp+12]-&gt;esi</span><br>    mov <span class="hljs-number">16</span>(%ebp), %edi ;<span class="hljs-comment">//move the third parameter into EDI.</span><br>    mov %edi, <span class="hljs-number">-4</span>(%ebp) ;<span class="hljs-comment">//move EDI to temperary variable.</span><br>    add %esi, <span class="hljs-number">-4</span>(%ebp) ;<span class="hljs-comment">//add ESI to temperary variable</span><br>    add <span class="hljs-number">-4</span>(%ebp), %eax ;<span class="hljs-comment">// add the value of temperary variable to eax; </span><br>    ; <span class="hljs-comment">// the end of the subroutine</span><br>    pop %esi ;<span class="hljs-comment">//restore the value of the</span><br>    pop %edi<br>    mov %ebp, %esp ;释放局部变量<br>    pop %ebp ;恢复调用者的基指针值<br>    ret<br></code></pre></td></tr></table></figure><h1 id="x64-assembler">X64 Assembler</h1><p>x86-64 is the 64-bits version of x86. Most registers are generalpurpopse. While some have specific function. - rsp: used as the stackpointer. - rax: the function return value.</p><h3 id="setx-and-movx">setx and movx</h3><p>execute the instruction if x(the condition) is true.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xmp">sete dst; if equal then set the dst from 0 to 1.<br>setge dst; if greater equal, set the dst from 0 to 1.<br>cmovle src, dst; if less equal ,mov the src to dst. <br></code></pre></td></tr></table></figure></p><h1 id="elf">ELF</h1><ul><li>ELF header: in the front of the file, describe the the basicproperties.</li><li>Program header table: is optional, it tells the system how to createa process image. The executable file must have a program header table,and the relocatable files do not need.</li><li>section:</li></ul><h2 id="readelf">readelf</h2><h3 id="analysis">analysis</h3><p>a better way to use readelf, is using c++filter to change demanglesymbol name into readable symbol name. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$readelf</span> -Ws &lt;library&gt; | c++filt<br></code></pre></td></tr></table></figure></p><h3 id="find-dependant-libraries">find dependant libraries</h3><p>can simply use ldd to find out, or usign readelf and grep command.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$readelf</span> -d &lt;executable binary|library&gt; | grep NEEDED<br></code></pre></td></tr></table></figure></p><h1 id="memory">Memory</h1><p>In order to use the user program in the runtime has a private addressspace, has its own CPU, just like the exclusivity of the entire computeras a modern operating system proposes the virtual memory concept.</p><h2 id="stack">Stack</h2><p>Is the First In First Out(FIFO) volume. Stack grow from high memoryaddress to low memory address, <code>ebp</code> is pointed to the bottonof the stack, while <code>esp</code> is pointed to the top of the stack.- <code>Push</code>: <code>esp</code> will minus, and put the operandinto the address where the <code>rsp</code> pointed to. -<code>Pop</code>: get the number inside <code>esp</code> and minus<code>esp</code> with 4.</p><h3 id="calling-convention-of-x86-system">calling convention of x86system</h3><ol type="1"><li>push specific parameter into stack.</li><li>push the next instruction into stack.</li><li>jump to the function.</li></ol><p>the second step and the third step execute with<code>call</code>.</p><h3 id="the-beginning-of-the-function-of-x86">the beginning of thefunction of x86</h3><ul><li>begin<ul><li><code>push ebp</code> -&gt;push ebp into stack.</li><li><code>mov ebp, esp</code>-&gt;make the botton of the stack be thetop of the stack</li><li><code>sub esp, xxx</code>-&gt;create spaces for the stack.</li></ul></li><li>return<ul><li><code>pop XXX</code> : restore the stored register value.</li><li><code>mov esp, ebp</code>: make the top of the stack the addresswhere it used to start.</li><li><code>pop ebp</code>: get the stored ebp value.</li><li><code>ret</code> : get the return address from the stack and returnto the main function.</li></ul></li></ul><h2 id="reference">Reference</h2><p>https://www.bookstack.cn/read/CTF-All-In-One/doc-1.4_web_basic.md</p>]]></content>
    
    
    
    <tags>
      
      <tag>Reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wargame_Leviathan</title>
    <link href="/2023/09/22/Wargame-Leviathan/"/>
    <url>/2023/09/22/Wargame-Leviathan/</url>
    
    <content type="html"><![CDATA[<p>This is a write up of Leviathan. Leviathan is a wargame, mostly aboutreverese engineering. There are seven level in this wargame. I collectthe key to every level at the end of this blog, please use it if youwant to get access of certain level.</p><h2 id="leviathan0">Leviathan0</h2><p>first use string to detect some useful imformation, and we can findout their is a password inside. Then we cansimply use grep to findoutthe password. <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$cat</span> bookmark.htmp|grep password. <br></code></pre></td></tr></table></figure></p><h2 id="leviathan1">Leviathan1</h2><ul><li>Their is a ececutable file inside. so i use radare2 to see theoutlook of the program. we can fond fourstring"secret","god","sex","love" inside. inside and the and before thefunction call strcmp function, the put "sex" into the register, so wecan know that this program check the input with "sex".</li><li>Therefore, i simply input sex, and get the root of leviathan2, andthen cat the password file inside 'Leviathan_pass/Leviathan2'</li></ul><h2 id="leviathan2">Leviathan2</h2><p>this one is a hard question, this problem i look out other people'swrite up, and they utilize the access function. when their is a filewith a space inside the filename, the access function will check the twofile seperately. &gt;For example, if the filename is "hank heroine.txt",then the access function &gt;will check both hank and heroine inside thefile.</p><p>After using radare2 to check the function, we can see that thefunction will printout the file using the shell of leviathan3.Therefore, I make a file named <code>hank\ heroine.txt</code> and make alink from heroine.txt to <code>/etc/leviathan_pass/leviathan3</code></p><h2 id="leviathan3">Leviathan3</h2><p>simply using <code>ltrace</code> to see how this file work. We canfind out that this program call a strcmp function, and compare the inputwith a specific string "snlprintf". so we can get the shell ofleviathan4.</p><h2 id="leviathan4">Leviathan4</h2><p>another simple problem, use <code>ltrace</code> we can find out thisprogram call the <code>fopen</code> function, so we can know that thisfunction is printing the content of the password. the only thing we needto do is to tranfer the ASCII code into strings.</p><h2 id="leviathan5">Leviathan5</h2><p>This program open the file at <code>/etc/file.log</code> but their isno such file. What's more this program print out the file using theshell of leviathan6. Similar to Leviathan2, I create a linkage between<code>/etc/file.log</code> and<code>/etc/leviathan_pass/leviathan6</code> , so it will print out thecontent of leviathan6.</p><h2 id="leviathan6">Leviathan6</h2><ul><li>First i use <code>ltrace</code> to find out what this program, and ifound that it calls the <code>atoi</code> function, which transfer astring into an interger. So i think the correct code of this function isinside this program.</li><li>Therefore, i use radare2 to reassemble the program, and there is onevar that store a hex number<code>1bd3</code>, and the later compare codealso compare the input with this variable.</li><li>So i use the Decimal number <code>7123</code> (0x1bd3) as the codeof this program. and get the shell of leviathan7.</li></ul><h2 id="leviathan7">Leviathan7</h2><p><img src="https://hackmd.io/_uploads/B1Yg6sMKn.png" /></p><h2 id="the-password-to-every-tlevel">the password to every tlevel</h2><center><table><thead><tr class="header"><th>level</th><th style="text-align: center;">password</th></tr></thead><tbody><tr class="odd"><td>leviathan1</td><td style="text-align: center;">PPIfmI1qsA</td></tr><tr class="even"><td>leviathan2</td><td style="text-align: center;">mEh5PNl10e</td></tr><tr class="odd"><td>leviathan3</td><td style="text-align: center;">Q0G8j4sakn</td></tr><tr class="even"><td>leviathan4</td><td style="text-align: center;">AgvropI4OA</td></tr><tr class="odd"><td>leviathan5</td><td style="text-align: center;">EKKlTF1Xqs</td></tr><tr class="even"><td>leviathan6</td><td style="text-align: center;">YZ55XPVk2l</td></tr><tr class="odd"><td>leviahtan7</td><td style="text-align: center;">8GpZ5f8Hze</td></tr></tbody></table></center>]]></content>
    
    
    
    <tags>
      
      <tag>Wargame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>獨立研究</title>
    <link href="/2023/01/15/%E7%8D%A8%E7%AB%8B%E7%A0%94%E7%A9%B6/"/>
    <url>/2023/01/15/%E7%8D%A8%E7%AB%8B%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="獨立研究">獨立研究</h1><h2 id="研究動機">研究動機</h2><p>自然界中，許多生物具有特定的顏色，此種顏色可分為色素色與結構色兩大類，色素色為生物表層具有可以發散特定波長光線的官能機，因此吸收所有光線並反射特定波長的光線，以至於呈現特定顏色；結構色則是因為光線在奈米結構中散射、干涉與繞射產生光波長的選擇性反射。因此，此研究想探討奈米粒子，藉由緊密堆積與控制粒徑使奈米粒子呈現出不同顏色。</p><p>在先前的研究中，我們致力於製作力致變色可拉伸薄膜，因為其無須能源即可變色或是從透明變成有色的特性，使其成為一個良好的環保材料，具有智慧材料的潛力，因此被運用於許多層面，例如環保智能顯示器、應力示警。然而先前的研究成果沒有如預期中的具有高反射率的性質，因此在個別研究中，我想退一步從該研究並沒有仔細探討的薄膜的基材自組裝著手。</p><p>我認為若是提高自組裝的品質將可以有效地使薄膜的反射率增加，因此本研究將聚焦於各種不同的自組裝程序，包含垂直對流性自組裝與滴狀膠體溶液溶液對流性自組裝，嘗試不同條件下進行對流性自組裝，找出最成功的自組裝製程。</p><p>此外，在專題研究期間發現無法利用垂直對流自組裝將粒徑大於500nm的二氧化矽奈米粒子規則排列於玻片之上。因此，本研究將探討如何使大粒徑的二氧化矽奈米粒子利用垂直對流自組裝將粒徑大於500nm的二氧化矽奈米粒子規則排列於玻片之上。</p><h1 id="研究心得">研究心得</h1><p>高一時看到學姊的報告，看到一堆奈米粒子球的SEM，立刻被這些密集堆積的球球吸引住，心想這個實驗室真酷，一堆奈米粒子，看起來就很好玩，一定要去這個實驗室做專題。</p><p>沒想到一待就是3年。這段期間內，我做了許多二氧化矽自組裝跟力至變色光子晶體的實驗，研究到一半時我發現自己欠缺奈米實驗最需要的耐心跟謹慎，微小的誤差常常被放大，連續數次的失敗讓我在研究中期陷入負面情緒。然而經歷了無數次成果無情的摧殘並在中興度過許多假日後，我完成了個別研究，並參加全國科學班比賽有幸能獲得教授的青睞拿到了佳作。</p><p>十分感謝宏達教授，雖然他不曾到實驗室親自指導我，但是常常在一個小時內回我email，很感謝他全力的支持，以及有趣、開放的對話方式（高三才解鎖的）。也感謝跟我同一實驗室的朋友毓修、哲源跟則璁，有你們一起面對困難，我才能繼續堅持下去把研究做完。更感謝學長幫我用SEM找自組裝的結構跟測量粒徑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HighSchool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TheVeryBeginning</title>
    <link href="/2023/01/15/TheVeryBeginning/"/>
    <url>/2023/01/15/TheVeryBeginning/</url>
    
    <content type="html"><![CDATA[<h1 id="my-first-post">My first post</h1><h2 id="這個部落格">這個部落格</h2><p>今天來建了這個靜態網站，用<code>hexo</code>架出來的，就是一直套用模板，目前正在努力改模板，希望能把自己的部落格做的漂亮一點。之後應該會把這個網站加上一些酷酷的東西，像是頭會動的貓貓還有酷酷的特效之類的。關於這個網頁，然後這個部落格我用的 theme 是 <strong>fluid</strong>模板，然後我目前遇到的技術上的困難是我更改<code>/public/img</code>的圖片之後網頁上傳github之後網站會的圖片跟文章會更新，但是它的色彩卻沒有更新；相對地當我想要用localhost先預覽的時候我卻發現他的圖片並沒有變動，但是顏色有更動。&gt;因為今天要測試網站下拉的樣式，所以上面放了兩篇高中時候的東西，也算是高中記錄。## 來由關於為何要件這個網站呢，簡單記錄一些有趣的活動、大學修課的心得，一些自己學習的心路歷程，或是分享一些筆記之類的(大一上有用notion做一些筆記，看之後能不能傳上來)。加上之前看到兩個資工電神在架，感覺非常有趣，想說恰巧放寒假就來架一下。</p><h2 id="今日份的筆記">今日份的筆記</h2><ul><li>以下是hexo之後會常常用到的指令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;xxx&quot;</span> = hexo new <span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment"># 新增名為 xxx 的文章</span><br>hexo g = hexo generate <span class="hljs-comment"># 生成靜態網站</span><br>hexo s = hexo sever <span class="hljs-comment"># 啟動本地預覽</span><br>hexo d = hexo deploy <span class="hljs-comment"># 部屬網站</span><br>hexo clean <span class="hljs-comment"># 清除緩存 ，一般不會用到</span><br></code></pre></td></tr></table></figure></li><li>一個今天遇到的技術上的問題 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">. : 因為這個系統上已停用指令碼執行，所以無法載入 C:UsersUSERNAMEDocumentsWindows<br>PowerShellprofile.ps1 檔案。如需詳細資訊，請參閱 about<span class="hljs-emphasis">_Execution_</span>Policies，網址為<br>https:/go.microsoft.com/fwlink/?LinkID=135170。<br>位於 線路:1 字元:3<br><span class="hljs-bullet">+</span> . &#x27;C:UsersUSERNAMEDocumentsWindowsPowerShellprofile.ps1&#x27;<br><span class="hljs-bullet">+</span>   <span class="hljs-code">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-bullet">    +</span> CategoryInfo          : SecurityError: (:) [], PSSecurityException<br><span class="hljs-bullet">    +</span> FullyQualifiedErrorId : UnauthorizedAccess<br></code></pre></td></tr></table></figure>後來用administrator的身分開啟shell，然後打下面的指令就解決了，雖然我也不是很確定為甚麼可以這樣解決，但是我卡在這個地方快一個小時，所以還是紀錄一下。<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Set</span>-ExecutionPolicy <span class="hljs-comment">RemoteSigned</span><br></code></pre></td></tr></table></figure> 後記:後來發現為何generate的顏色跟localhost會不同，因為有一些暫存放在裡面沒有被更新，所以要先用<code>hexo clean</code>把暫存都先清掉，然後在將整個網站generate之後deploy上去。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
